## js内存管理

JavaScript 具有自动垃圾回收机制（简称GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存，垃圾回收机制完全实现变量内存分配和内存回收的自动管理，而在 C 和 C++ 之类的语言中，开发人员有些时候需要手工分配(malloc)和回收(Garbage)内存。

**js内存分为栈区和堆区。**

- 栈区： 栈区内存由操作系统自动分配和释放，如函数的局部变量，函数参数等。
- 堆区：一般由开发者释放，这部分空间需要考虑垃圾回收问题。

一般情况下，基本数据类型保存在栈内存当中，引用类型保存在堆内存当中。如下代码

```
var a = 11
var b = 10
var c = [1, 2, 3]
var d = { e: 20 }
```

对应内存分配图示：

![img](https://cdn.nlark.com/yuque/0/2022/png/26361372/1647402156171-cc1dc145-b5bd-49b2-8951-63c8bc9a9afa.png)

## 内存的生命周期



- 分配内存
- 使用（读写）内存
- 释放内存

```
var obj = {a:1}; //  分配内存
console.log(foo); // 使用内存
obj = null; // 释放内存
```

## **浏览器垃圾回收**

当然，除了开发者主动保证以外，大部分的场景浏览器都会依靠：

- 标记清除。 当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。。而当函数执行完毕之后，变量离开环境时，则将其标记为“离开环境
- 引用计数。 引用计数的含义是跟踪记录每个值被引用的次数。当垃圾收集器下次再运行时，它就会释放那些引用次数为零的对象所占用的内存

两种算法来进行主动垃圾回收：

-  标记清除
- 引用计数

```
// 标记清除
function test(){
    var a = 10 ; // 被标记 ，进入环境
    var b = 20 ; // 被标记 ，进入环境
    
}

test(); // 执行完毕 之后 a、b又被标离开环境，被回收 。最后销毁那些带标记的值并回收它们所占用的内存空间
```

```
// 引用计数
var a = {} ; // a的引用次数为1
var b = a ; // a的引用次数加1，为2
var c = a; // a的引用次数再加1，为3

var b = null; // a的引用次数减1，为2
var c = null; // a的引用次数减1，为1
var a = null; // a的引用次数减1，为0 , js垃圾回收机制会自动回收

```



但是对于**全局变量的引用**，可以通过将其值**设置为 null 来释放其引用——这个做法叫做 解除引用**。



## 内存泄漏

对于分配内存和读写内存的行为所有语言都较为一致，但释放内存空间在不同语言之间有差异。例如，JavaScript 依赖宿主浏览器的垃圾回收机制，一般情况下不用程序员操心。但这并不表示万事大吉，某些情况下依然会出现内存泄漏现象。

内存泄漏：内存空间无法释放。

内存泄漏危害：它会直接导致程序运行缓慢，甚至崩溃



**常见内存泄漏场景：**

- 意外的全局变量
- 无效的DOM引用
- 没关闭的时间器
- ....





- 意外的全局变量

```javascript

function foo() {
    // 实际上是 window.bar = "this is an explicit global variable";
    bar = "this is a hidden global variable";
}

foo()
```





练习题：

练习1：

```javascript
    var arr1 = [1,2,3];
    var arr2 = arr1;
    arr2.push(4); 
    arr2 = null;
    console.log(arr1) // ?
    console.log(arr2) // ?

```

> 注意！！！ 给引用类型赋值为null，代表解除引用。即不在指向堆内存中的某个地址

练习2：

```javascript
var arr1 = [1,2,{name:'小可爱'}]；
var arr2 = arr1;
arr2[2].name = '小公举'
var arr3 = arr2;
arr1.push(3)
console.log(arr1)
console.log(arr2)
console.log(arr3)
```



  